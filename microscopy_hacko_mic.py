# -*- coding: utf-8 -*-
"""microscopy_hacko_mic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19XA3LMJTb3CTdM1iAQY_7fkAt44FYgiV
"""
# for visualizing
from ase import Atoms
from ase.io import write
from ase.visualize import view


def view_x3d(atoms, idx=0):
    if isinstance(atoms[0], Atoms):
        # Assume this is a trajectory or struct list
        if len(atoms) <= idx:
            print(
                f"The specified index exceeds the length of the trajectory. The length of the trajectory is {len(atoms)}."
            )
        return view(atoms[idx], viewer="x3d")
    else:
        return view(atoms, viewer="x3d")


"""##STM images - Al(111)

https://gpaw.readthedocs.io/tutorialsexercises/electronic/stm/stm.html
"""

from ase.build import fcc111

atoms = fcc111("Al", size=(1, 1, 2))
atoms.center(vacuum=4.0, axis=2)

view_x3d(atoms)

from gpaw import GPAW

calc = GPAW(mode="pw", kpts=(4, 4, 1), symmetry="off", txt="al111.txt")
atoms.calc = calc
energy = atoms.get_potential_energy()
calc.write("al111.gpw", "all")

from ase.dft.stm import STM
from gpaw import GPAW

calc = GPAW("al111.gpw")
atoms = calc.get_atoms()
stm = STM(atoms)
z = 8.0
bias = 1.0
c = stm.get_averaged_current(bias, z)
x, y, h = stm.scan(bias, c, repeat=(3, 5))

# constant current height
import matplotlib.pyplot as plt

plt.gca().axis("equal")
plt.contourf(x, y, h, 40)
plt.colorbar()
plt.savefig("2d.png")

# constant height scan
plt.figure()
plt.gca().axis("equal")
x, y, I = stm.scan2(bias, z, repeat=(3, 5))
plt.contourf(x, y, I, 40)
plt.colorbar()
plt.savefig("2d_I.png")


"""##Scanning tunneling spectroscopy"""

plt.figure()
biasstart = -2.0
biasend = 2.0
biasstep = 0.05
bias, I, dIdV = stm.sts(0, 0, z, biasstart, biasend, biasstep)
plt.plot(bias, I, label="I")
plt.plot(bias, dIdV, label="dIdV")
plt.xlim(biasstart, biasend)
plt.legend()
plt.savefig("dIdV.png")

"""##STM simulations

https://gitlab.com/gpaw/gpaw/blob/master/doc/tutorialsexercises/electronic/stm_ex/HAl100.py

https://gitlab.com/gpaw/gpaw/blob/master/doc/tutorialsexercises/electronic/stm_ex/stm.py
"""

from ase import Atoms
from gpaw import GPAW

a = 4.0
b = a / 2**0.5
L = 11.0

# Set up 2-layer 2x2 (100) Al-slab:
slab = Atoms(
    "Al2", positions=[(0, 0, 0), (b / 2, b / 2, -a / 2)], cell=(b, b, L), pbc=True
)
slab *= (2, 2, 1)

if True:
    # Add adsorbate:
    slab += Atoms("H", [(b, b, 1.55)])

slab.center(axis=2)

calc = GPAW(mode="pw", kpts=(4, 4, 1))
slab.calc = calc
slab.get_potential_energy()
calc.write("HAl100.gpw", "all")

from sys import argv
import matplotlib.pyplot as plt

from ase.dft.stm import STM
from gpaw import restart

# filename = argv[1] # Original line
filename = "HAl100.gpw"  # Fixed to use the generated file
z0 = 8
bias = 1.0

atoms, calc = restart(filename, txt=None)

stm = STM(atoms, symmetries=[0, 1, 2])
c = stm.get_averaged_current(bias, z0)

print(f"Average current at z={z0:f}: {c:f}")

# Get 2d array of constant current heights:
x, y, h = stm.scan(bias, c)

print(f"Min: {h.min():.2f} Ang, Max: {h.max():.2f} Ang")

plt.contourf(x, y, h, 40)
plt.hot()
plt.colorbar()
plt.show()

"""##Molecule image descriptors in ppafm

https://ppafm.readthedocs.io/en/latest/tutorials/auxmap-tutorial.html

https://github.com/Probe-Particle/ppafm/blob/main/examples/Generator/example_molecules/bcb.xyz
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile bcb.xyz
# 12
#
# 35 10.654831 9.925166 -0.113755 0.009160
# 17 8.316881 4.875528 0.126604 -0.036140
# 17 5.124221 9.268966 -0.015263 -0.036330
# 6 9.108196 8.803656 -0.048246 -0.226580
# 6 7.842933 9.394246 -0.056558 0.176220
# 6 9.278226 7.418870 0.007561 0.176110
# 6 8.134151 6.618784 0.055767 -0.183820
# 6 6.727301 8.555293 -0.006960 -0.183890
# 6 6.849534 7.165703 0.049422 0.177700
# 1 7.724396 10.475141 -0.099925 0.041930
# 1 10.270325 6.971431 0.013763 0.041960
# 1 5.969004 6.527218 0.087589 0.043690

import numpy as np
from matplotlib import pyplot as plt

from ppafm.io import loadXYZ
from ppafm.ml.AuxMap import AtomicDisks, ESMapConstant, HeightMap, vdwSpheres
from ppafm.ocl.AFMulator import AFMulator

# Load a sample
xyzs, Zs, qs, _ = loadXYZ("bcb.xyz")

# The AuxMaps expect the xyz coordinates and point charges to be in the same array
xyzqs = np.concatenate([xyzs, qs[:, None]], axis=1)

# We need an instance of the AFMulator for the HeightMap specifically
afmulator = AFMulator(scan_dim=(128, 128, 30), scan_window=((0, 0, 6), (16, 16, 9)))

# The scan region for the AuxMaps is given in similar way as for the AFMulator, except that it's 2D instead of 3D.
scan_dim = (128, 128)
scan_window = ((0, 0), (16, 16))

# Construct instances of each AuxMap
vdw_spheres = vdwSpheres(
    scan_dim=scan_dim, scan_window=scan_window, zmin=-1.5, Rpp=-0.5
)
atomic_disks = AtomicDisks(scan_dim=scan_dim, scan_window=scan_window, zmin=-1.2)
height_map = HeightMap(scanner=afmulator.scanner, zmin=-2.0)
es_map = ESMapConstant(
    scan_dim=scan_dim, scan_window=scan_window, vdW_cutoff=-2.0, Rpp=1.0
)


# Evaluate each AuxMap for the molecule
y_spheres = vdw_spheres(xyzqs, Zs)
y_disks = atomic_disks(xyzqs, Zs)
y_es = es_map(xyzqs, Zs)

# The HeightMap is special in that it requires the force field for the probe particle to be calculated beforehand,
# so we first run afmulator with the molecule to generate the force field
afm = afmulator(xyzs, Zs, qs)
y_height = height_map(xyzqs, Zs)

# Make a plot
fig, axes = plt.subplots(1, 5, figsize=(14, 4), gridspec_kw={"wspace": 0.02})
axes[0].imshow(afm[:, :, -1].T, origin="lower", cmap="gray")
axes[1].imshow(y_spheres.T, origin="lower")
axes[2].imshow(y_disks.T, origin="lower")
axes[3].imshow(y_height.T, origin="lower")
vmax = max(
    y_es.max(), -y_es.min()
)  # Make the ES Map value range symmetric so that zero is in the middle of the color range (white)
vmin = -vmax
axes[4].imshow(y_es.T, origin="lower", cmap="coolwarm", vmin=vmin, vmax=vmax)

axes[0].set_title("AFM sim.")
axes[1].set_title("vdW Spheres")
axes[2].set_title("Atomic Disks")
axes[3].set_title("Height Map")
axes[4].set_title("ES Map")

for ax in axes:
    ax.set_xticks([])
    ax.set_yticks([])

# Save image to disk
plt.savefig("auxmaps.png", bbox_inches="tight")
